<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-15">

    <title>CA_PROJECT_2 - Torben Petre&#769; en Etienne El Hachem</title>
    <style type="text/css">
        * {box-sizing:border-box;}
        body {font-family:"Verdana";font-size:16px;padding:25px;max-width:800px;margin:0 auto;}
        h1 {margin-top:25vh;}
        u {text-decoration: overline;}
        img {padding:12.5px;max-width: 100%;max-height:80vh;}
        footer {margin-top:10vh;text-align:center;font-size:15px;}
        li {margin-bottom:5px;}
        note {font-size:14px;color: #464646;}
        span {text-wrap:nowrap;}
        summary {margin:10px 0px;cursor:pointer;}
    </style>
</head>
<body>
    <h1>Verslag</h1>
    <p>
        <b>Titel:</b> <i>Project 2: CA_PROJECT_2</i>
    </p>
    <p>
        Dit verslag werd opgesteld door:
    </p>
    <ul>
        <li>
            <b>Naam:</b> <i>Etienne El Hachem</i><br>
            <b>Studentennummer:</b> <i>20241443</i><br>
            <b>Email adres:</b> <i>etienne.elhachem@student.uantwerpen.be</i>
        </li>
        <li>
            <b>Naam:</b> <i>Torben Petre&#769;</i><br>
            <b>Studentennummer:</b> <i>20241699</i><br>
            <b>Email adres:</b> <i>torben.petre@student.uantwerpen.be</i>
        </li>
    </ul>
    <b>Aantal man-uren besteed:</b> <i>x uur</i><br>
    <b>Moeilijkheidsgraad:</b> <i>xx</i> /10 (1 is heel makkelijk, 10 is heel moeilijk)<p></p>

    <h2>Inhoud van de oplossing</h2>
    <p>
        De oplossing bestaat uit de volgende bestanden (geef alle bestanden op):
    </p>
    <ul>
        <li>
            <a href="./bestand.ext" target="_blank">bestand1.ext</a>: toelichting van bestand1.ext
        </li>
        <li>
            <a href="./bestand.ext" target="_blank">bestand2.ext</a>: toelichting van bestand2.ext
        </li>
    </ul>

    <h2>1-bit full adder</h2>
    <p>
        Een <i>1-bit full adder</i> heeft als inputs een A en B (de bits die
        je wilt optellen) en een CarryIn. Als output geeft het de som van A en 
        B en een CarryOut (indien relevant). We geven ook meteen de na&iuml;ve
        implementatie mee. Dit is snelts mogelijke oplossigen, maar we gebruiken
        een onnodig grote hoeveelheid gates. Daarom zullen we dit verder nog
        optimaliseren.
    </p>

    <div style="text-align:center;">
        <img src="1_bit_ongeoptimaliseerd.png" alt="1 bit niet geoptimaliseerd"/>
    </div>

    <p>
        We zullen de waarhiedstabel om te zetten naar een booleaanse expressie 
        voor zowel R (het resultaat van de som) als Co (de CarryOut). Deze 
        kunnen we dan volgens vereenvoudigen.
    </p>

    <b>R:</b> (<u>A</u> &middot; <u>B</u> &middot; Ci) + (<u>A</u> &middot; B &middot; <u>Ci</u>) + (A &middot; <u>B</u> &middot; <u>Ci</u>) + (A &middot; B &middot; Ci)
    <details>
        <summary>= Amazing</summary>

        <ul>
            <li>
                [Ci &middot; ((<u>A</u> &middot; <u>B</u>) + (A &middot; B))] + [<u>Ci</u> &middot; ((A &middot; <u>B</u>) + (<u>A</u> &middot; B))]
            </li>
            <li>
                [Ci &middot; (<u>A</u> XOR B)] + [<u>Ci</u> &middot; (A XOR B)]
            </li>
            <li>
                (Ci &middot; <u>Ci</u>) AND (<u>A</u> XOR B)] + [<u>Ci</u> &middot; (A XOR B)]
                <note>(Distributive law)</note>
            </li>
        </ul>
    </details>
    
    <b>Co:</b> (<u>A</u> &middot; B &middot; Ci) + (A &middot; <u>B</u> &middot; Ci) + (A &middot; B &middot; <u>Ci</u>) + (A &middot; B &middot; Ci)
    
    <p>
        Geoptimaliseerd <br><br>
        b. Convert the truth table to Boolean algebra, and optimize the Boolean expression. <br>
        c. Implement the Boolean expression as a circuit called “1-Bit Adder” in Logisim.
    </p>

    <div style="text-align:center;">
        <img src="1_bit_geoptimaliseerd.png" alt="1 bit geoptimaliseerd"/>
    </div>

    <h2>12-bit two's complement ripple carry adder</h2>

    <p>
        Nu plaatsen we 12 van onze voorgaande 1-bit full adders achter elkaar.
        Onze 1-bit full adder had een CarryIn en een CarryOut. We zullen
        telkens de CarryOut van de vorige adder als CarryIn met de volgende
        adder meegeven. Dit is ook waarom men spreekt van een Ripple Carry 
        Adder. De eerste adder kreegt een input CarryIn en de laaste input
        wordt gebruikt om overflow te bepalen.
    </p>

    <p>
        Overflow bestaat uit twee situaties:
    </p>
    
    <ol>
        <li>
            Je telt twee positieve getallen op die een negatief getal vormen.
            <p>
                Dit kan gebeuren wanneer de som van twee 12-bit (positieve)
                getallen een nieuw 12-bit getal vormen waarbij de most 
                significant een 1 wordt. We weten dat bij two's complement, de
                most significant bit het teken van het getal weergeeft (waarbij
                1 negatief representeert). Daardoor weten we dat wanneer het
                resultaat een 1 als most significant bit heeft, dat twee 
                positieve getallen negatief worden.
            </p>
        </li>
        <li>
            Je telt twee negatieve getallen op die een positief getal vormen.
            <p>
                Dit werkt op een gelijkaardige manier als het vorige puntje.
                Wanneer de som van negatieve getallen en nog groter negatief
                getal is (dat niet met 12 bits gerepresenteerd kan worden) zal
                de most significant bit niet langer correct het teken van het
                getal weergeven.
            </p>
        </li>
    </ol>
    
    <p>
        Om dit te implementeren kijken we naar de most significant bits van de
        input getallen A en B. Als deze dezelfde zijn en verschillen van de 
        most significant bit van het resultaat, weten we dat er overflow is.
    </p>

    <div style="text-align:center;">
        <img src="12_bit_ripple_carry_adder.png" alt="12 bit ripple carry adder"/>
    </div>

    <h2>12-bit two's complement carry lookahead adder</h2>
    <p>
        Onze 12-bit two's complement carry lookahead adder zal bestaan uit 3 
        4-bit carry lookahead adders en een carry lookahead unit. 
    </p>  
    
    <p>
        Voor onze 4-bit Carry Lookahead Adder berekende we telkens de 
        propagates en generates voor alle inputs (A en B). Dit doen we omdat 
        deze gebruikt kunnen worden om zowel de grote Propogate en Generate te 
        berekenen als de verwachte som. We hebben zo weinig mogelijk gates
        gebruikt voor onze implementatie. We komen op een totaal van 6 epsilon.
    </p>

    <p>
        In rood zie je het langste pad dat uit 6 gates bestaat. De oranje pijl
        toent dat de oranje gate in parallel met de eerste serie rode gates 
        wordt berekent.
    </p>

    <div style="text-align:center;">
        <img src="4_bit_carry_lookahead_adder.png" alt="4 bit carry lookahead adder"/>
    </div>

    <p>
        Onze Carry Lookahead Unit neemt de Propagates en Generates die door
        onze 4-bit adders worden berekent en bepaald de CarryIn voor de 
        volgende adder.
    </p>

    <div style="text-align:center;">
        <img src="carry_lookahead_unit.png" alt="Carry lookahead unit"/>
    </div>

    <p>
        Wanneer je onze circuits dan combineert krijg je het volgende.
    </p>

    <div style="text-align:center;">
        <img src="12_bit_carry_lookahead.png" alt="12 bit carry lookahead unit"/>
    </div>

    <p>
        Door gebruik te maken van the Carry Lookahead Unit, kunnen we veel 
        sneller uitkomsten berekenen dan met de Ripple Carry. De CarryIns van
        alle adders worden in parallel berekent met het eindresultaat.
    </p>
</body>
</html>